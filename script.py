from __future__ import annotations

from asyncio import create_task, sleep
from itertools import chain
from re import findall, split
from sys import version as pythonVersion
from typing import cast, Any, ClassVar, TYPE_CHECKING

from coolname import generate_slug  # type: ignore[attr-defined]

from pyscript import when, window, storage, Storage  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module
from pyscript.web import page  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module
from pyscript.ffi import to_js  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module

try:  # Try to identify PyScript version
    from pyscript import version as pyscriptVersion  # type: ignore[attr-defined]
except ImportError:
    try:
        from pyscript import __version__ as pyscriptVersion
    except ImportError:
        pyscriptVersion = next(tag.src for tag in page['script']).split('/')[-2] or "UNKNOWN"

from pyodide_js import version as pyodideVersion  # type: ignore[import-not-found]  # pylint: disable=import-error, wrong-import-order

from Steganography import getImageMode, imageToBytes, loadImage, processImage

if TYPE_CHECKING:
    from collections.abc import Mapping

    Event = Any  # Workarounds for mypy as stuff cannot be imported from PyScript when not in a browser
    Element = Any
    Blob = Any
    Uint8Array = Any
    Storage = Any
    def createObjectURL(_file: Any) -> str: return ''  # pylint: disable=multiple-statements
    def revokeObjectURL(_url: str) -> None: pass  # pylint: disable=multiple-statements
else:
    Blob = window.Blob  # Simplifying addressing to JS classes and functions
    Uint8Array = window.Uint8Array
    createObjectURL = window.URL.createObjectURL
    revokeObjectURL = window.URL.revokeObjectURL
    window = None  # For cleaner code, make sure all used references are mentioned here

# ToDo: these:
# Global error handling
# Task name (default: date_time)
# Input image (upload, regenerate)
# Lock image (upload, remove)
# Key image (upload, remove)
# Lock result (download)
# Key result (download)
# Test (download) - make it with really two images overlaid!
# Move loading log to the bottom
# Check Rigging HTML for ideas

TEXT = 'text'

def log(*args: str) -> None:
    print(*args)

def getFileNameFromPath(path: str) -> str:  # It looks like 'pathlib' and `os` modules fail to parse `C:\fakepath\` paths generated by browser when uploading files
    return split(r'[/\\]', path)[-1]

def getRandomName() -> str:
    return cast(str, generate_slug(2))

async def repaint() -> None:
    await sleep(0.1)  # Yield control to the browser so that repaint could happen

def createObjectURLFromBytes(byteArray: bytes | Uint8Array) -> str:
    if isinstance(byteArray, bytes):
        byteArray = Uint8Array.new(byteArray)
    blob = Blob.new([byteArray,], to_js({'type': 'image/png'}))  # to_js() converts Python dict into JS object
    return createObjectURL(blob)

async def fileToByteArray(file: Any) -> Uint8Array:
    return Uint8Array.new(await file.arrayBuffer())

def getTagByID(tagID: str) -> Element:
    try:
        return page['#' + tagID][0]
    except IndexError:
        log("ERROR at getTagByID(): No tag ID found:", tagID)
        raise

def hide(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.add('hidden')

def show(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.remove('hidden')

def getAttr(element: str | Element, attr: str) -> str:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        return cast(str, element.innerText)
    return cast(str, element.getAttribute(attr))

def setAttr(element: str | Element, attr: str, value: str) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        element.innerText = value
    else:
        element.setAttribute(attr, value)

def removeChildren(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.innerHTML = ''

class Options(Storage):  # type: ignore[misc, no-any-unimported]

    OptionType = str | int | float | bool

    DEFAULT_VALUES: ClassVar[Mapping[type, int | float | bool]] = {int: 0, float: 1.0, bool: False}

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

        # These fields define correct names, types and default values for options:
        self.taskName = ''
        self.maxPreviewWidth = 500
        self.maxPreviewHeight = 200
        self.resizeSourceWidth = 0
        self.resizeSourceHeight = 0
        self.cropWidth = 0
        self.cropHeight = 0
        self.keyFactor = 1.0
        self.keyWidth = 0
        self.keyHeight = 0
        self.keyRotate = False
        self.lockFactor = 1.0
        self.lockWidth = 0
        self.lockHeight = 0
        self.keyResize = False
        self.smoothBackground = False

        for (name, defaultValue) in vars(self).items():
            if isinstance(defaultValue, Options.OptionType):
                self.configureTag(name, defaultValue)

    @staticmethod
    def getTag(name: str) -> Element:  # ToDo: Inline this method?
        return getTagByID('-'.join(chain(('option',), (word.lower() for word in findall(r'[a-z]+|[A-Z][a-z]*|[A-Z]+', name)))))

    def configureTag(self, name: str, defaultValue: Options.OptionType) -> None:
        value = self.get(name, defaultValue)
        assert isinstance(value, Options.OptionType), f"Incorrect type for option {name}: {type(value).__name__}, expected {type(defaultValue).__name__}"
        tag = self.getTag(name)
        if tag.type == 'checkbox':
            tag.checked = value
        else:
            tag.value = value
        log(f"Options.configureTag({name}, {defaultValue!r}): {type(tag).__name__} {tag.type} {tag.value!r}")

        @when('change', tag)  # type: ignore[untyped-decorator]
        async def update(e: Event) -> None:
            newValue: Options.OptionType = e.target.value
            assert isinstance(newValue, str), newValue
            if isinstance(defaultValue, str):
                if name == 'taskName' and not newValue:
                    newValue = getRandomName()
            elif newValue:  # int | float | bool
                newValue = type(defaultValue)(newValue)
            else:
                newValue = Options.DEFAULT_VALUES[type(defaultValue)]
            log(f"Options.update({name}, {newValue!r})")
            self[name] = newValue
            await self.sync()

    @classmethod
    async def init(cls) -> None:
        global options  # noqa: PLW0603  # pylint: disable=global-statement
        if not options:
            options = await storage('steganography', storage_class = cls)

    def __getattribute__(self, name: str) -> Any:  # ToDo: These methods are not needed?
        defaultValue = super().__getattribute__(name)
        log(f"Options.__getattribute__({name}) = {defaultValue!r}: {type(defaultValue).__name__} ({isinstance(defaultValue, Options.OptionType)})")
        if not isinstance(defaultValue, Options.OptionType):
            return defaultValue  # Not an option field
        ret = self.get(name, None)
        log(f"Options.get({name}) = {ret!r}")
        return defaultValue if ret is None else ret

    def __setattr__(self, name: str, value: Options.OptionType) -> None:
        # This method is not really used (configureTag().update() doesn't need it) but is provided here for completeness
        try:
            defaultValue = super().__getattribute__(name)
            log(f"Options.__getattribute__({name}) = {defaultValue!r}: {type(defaultValue).__name__} ({isinstance(defaultValue, Options.OptionType)})")
            if isinstance(defaultValue, Options.OptionType):
                if isinstance(defaultValue, float):
                    assert isinstance(value, int | float), f"Incorrect type for option {name}: {type(value).__name__}, expected int or float"
                else:
                    assert isinstance(value, type(defaultValue)), f"Incorrect type for option {name}: {type(value).__name__}, expected {type(defaultValue).__name__}"
                log(f"Options[{name}] = {value!r}")
                self[name] = value
                self.sync()
        except AttributeError:
            log(f"Options.__getattribute__({name}) = AttributeError")
        log(f"Options.__setattr__({name}) = {value!r}")
        super().__setattr__(name, value)

options: Options | None = None

def getImageBlock(name: str) -> Element:  # ToDo: Make these into a class
    return getTagByID('template').clone('image-block-' + name)

def showImage(name: str, byteArray: bytes | Uint8Array | None, description: str = "") -> None:
    if src := getAttr('image-display-' + name, 'src'):
        revokeObjectURL(src)
    setAttr('image-description-' + name, TEXT, description)
    show('image-description-' + name)
    if byteArray is None:  # E.g. Esc was pressed in upload dialog
        setAttr('image-display-' + name, 'src', '')
        setAttr('image-display-link-' + name, 'href', '')
        setAttr('image-download-link-' + name, 'href', '')
        hide('image-display-block-' + name)
        hide('image-download-block-' + name)
    else:
        url = createObjectURLFromBytes(byteArray)
        setAttr('image-display-' + name, 'src', url)
        setAttr('image-display-link-' + name, 'href', url)
        setAttr('image-download-link-' + name, 'href', url)
        show('image-display-block-' + name)
        show('image-download-block-' + name)

def renderImage(name: str, upload: bool = False) -> None:
    block = getImageBlock(name)
    for tag in block.find('*'):  # Assign named ids to all tags that have image-* classes
        for c in tag.classes:
            if c.startswith('image-'):
                tag.id = f'{c}-{name}'
                break
    getTagByID('uploads' if upload else 'generated').append(block)
    setAttr('image-title-' + name, TEXT, name.capitalize() + " file")
    setAttr('image-download-link-' + name, 'download', name + '.png')
    setAttr('image-name-' + name, TEXT, name + '.png')
    if upload:
        hide('image-description-' + name)
    else:
        hide('image-upload-block-' + name)
    show(block.id)

    @when('change', getTagByID('image-upload-' + name))  # type: ignore[untyped-decorator]
    async def uploadEventHandler(e: Event) -> None:
        removeChildren('generated')
        if fileName := e.target.value:
            fileName = getFileNameFromPath(fileName)
            setAttr('image-download-link-' + name, 'download', fileName)
            setAttr('image-name-' + name, TEXT, fileName)
            showImage(name, None, "Loading image...")
            await repaint()
            try:
                file = e.target.files.item(0)  # ToDo: Generate test event?
                byteArray = await fileToByteArray(file)
                image = loadImage(byteArray.to_bytes())
            except Exception as ex:  # noqa : BLE001
                showImage(name, None, f"Error loading image: {ex}")
                return
            showImage(name, byteArray, f"{file.size} bytes {image.format} {getImageMode(image)} {image.width}x{image.height}")
            renderImage('processed')
            showImage('processed', None, "Processing image...")
            await repaint()
            try:
                image = processImage(image)
            except Exception as ex:  # noqa : BLE001
                showImage(name, None, f"Error processing image: {ex}")
                return
            showImage('processed', imageToBytes(image), f"{getImageMode(image)} {image.width}x{image.height}")
        else:
            showImage(name, None)

def startLoading() -> None:
    setAttr('versions', TEXT, f'''\
PyScript: {pyscriptVersion}
Pyodide: {pyodideVersion}
Python: {pythonVersion}
    ''')

def finishLoading() -> None:
    show('content')

async def main() -> None:
    startLoading()
    await Options.init()
    renderImage('source', upload = True)  # ToDo: Make names constants
    finishLoading()

if __name__ == '__main__':
    create_task(main())  # noqa: RUF006

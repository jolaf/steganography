from __future__ import annotations

from asyncio import create_task, sleep
from enum import Enum
from itertools import chain
from re import findall, split
from sys import version as pythonVersion
from typing import cast, Any, ClassVar, TYPE_CHECKING

from coolname import generate_slug  # type: ignore[attr-defined]

from pyscript import document, when, window, storage, Storage  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module
from pyscript.web import page  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module
from pyscript.ffi import to_js  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module

try:  # Try to identify PyScript version
    from pyscript import version as pyscriptVersion  # type: ignore[attr-defined]
except ImportError:
    try:
        from pyscript import __version__ as pyscriptVersion
    except ImportError:
        pyscriptVersion = next(tag.src for tag in page['script']).split('/')[-2] or "UNKNOWN"

try:
    from pyodide_js import version as pyodideVersion  # type: ignore[import-not-found]
except ImportError:
    pyodideVersion = "UNKNOWN"

from js import CSSStyleSheet  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module, wrong-import-order

from Steganography import getImageMode, imageToBytes, loadImage, processImage

if TYPE_CHECKING:
    from collections.abc import Mapping

    # Workarounds for mypy, as stuff cannot be imported from PyScript when not in a browser
    Event = Any
    Element = Any
    Blob = Any
    Uint8Array = Any
    Storage = Any
    def createObjectURL(_file: Any) -> str: return ''  # pylint: disable=multiple-statements
    def revokeObjectURL(_url: str) -> None: pass  # pylint: disable=multiple-statements
    adoptedStyleSheets = Any
else:
    # Simplifying addressing to JS classes and functions
    Blob = window.Blob
    Uint8Array = window.Uint8Array
    createObjectURL = window.URL.createObjectURL
    revokeObjectURL = window.URL.revokeObjectURL
    window = None  # For cleaner code, make sure all used references are mentioned here
    adoptedStyleSheets = document.adoptedStyleSheets
    document = None

# ToDo: these:
# Global error handling
# Task name (default: date_time)
# Input image (upload, regenerate)
# Lock image (upload, remove)
# Key image (upload, remove)
# Lock result (download)
# Key result (download)
# Test (download) - make it with really two images overlaid!
# Move loading log to the bottom
# Check Rigging HTML for ideas

TagAttrValue = str | int | float | bool

TEXT = 'text'

def log(*args: Any) -> None:
    print(*args)

def getFileNameFromPath(path: str) -> str:
    # It looks like 'pathlib' and `os` modules fail to parse `C:\fakepath\` paths generated by browser when uploading files
    return split(r'[/\\]', path)[-1]

async def repaint() -> None:
    await sleep(0.1)  # Yield control to the browser so that repaint could happen

def createObjectURLFromBytes(byteArray: bytes | Uint8Array) -> str:
    if isinstance(byteArray, bytes):
        byteArray = Uint8Array.new(byteArray)
    blob = Blob.new([byteArray,], to_js({'type': 'image/png'}))  # to_js() converts Python dict into JS object
    return createObjectURL(blob)

async def fileToByteArray(file: Any) -> Uint8Array:
    return Uint8Array.new(await file.arrayBuffer())

def getTagByID(tagID: str) -> Element:
    try:
        return page['#' + tagID][0]
    except IndexError:
        log("ERROR at getTagByID(): No tag ID found:", tagID)
        raise

def hide(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.add('hidden')

def show(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.remove('hidden')

def getAttr(element: str | Element, attr: str) -> str:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        return cast(str, element.innerText)
    return cast(str, element.getAttribute(attr))

def setAttr(element: str | Element, attr: str, value: TagAttrValue, onlyIfAbsent: bool = False) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        if not onlyIfAbsent or not element.innerText:
            element.innerText = value
    elif not onlyIfAbsent or not element.getAttribute(attr):
        element.setAttribute(attr, value)

def removeChildren(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.innerHTML = ''

class Options(Storage):  # type: ignore[misc, no-any-unimported]
    TAG_ARGS: ClassVar[Mapping[type[TagAttrValue], Mapping[str, TagAttrValue]]] = {
        str: {
        },
        int: {
            'inputmode': 'numeric',
            'placeholder': 'integer',
            'pattern': r'[0-9]+',
            'default': 0,
        },
        float: {
            'inputmode': 'decimal',
            'placeholder': 'float resize factor',
            'pattern': r'\.[0-9]{1,2}|[0-9]+\.[0-9]{1,2}|[0-9]+\.?',
            'default': 1.0,
        },
        bool: {
            'type': 'checkbox',
            'default': False,
        },
    }

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        log("# Options: initializing default values")

        # These fields define names, types and DEFAULT values for options, actual values are stored in Storage
        self.taskName = ''
        self.maxPreviewWidth = 500
        self.maxPreviewHeight = 200
        self.resizeFactor = 1.0
        self.resizeWidth = 0
        self.resizeHeight = 0
        self.cropWidth = 0
        self.cropHeight = 0
        self.keyFactor = 1.0
        self.keyWidth = 0
        self.keyHeight = 0
        self.keyRotate = False
        self.lockFactor = 1.0
        self.lockWidth = 0
        self.lockHeight = 0
        self.keyResize = False
        self.dither = False
        self.smooth = False

        log("# Options: configuring tags and connecting them to options")
        for (name, defaultValue) in vars(self).items():
            if isinstance(defaultValue, TagAttrValue):
                self.configureTag(name, defaultValue)

        log("# Options: configuring stylesheet to adjust with options")
        self.styleSheet = CSSStyleSheet.new()
        adoptedStyleSheets.push(self.styleSheet)
        self.updateStyle()

    def configureTag(self, name: str, defaultValue: TagAttrValue) -> None:
        valueType = type(defaultValue)
        value = self.get(name, defaultValue)  # Read from database
        assert isinstance(value, valueType), f"Incorrect type for option {name}: {type(value).__name__}, expected {valueType.__name__}"
        tagID = '-'.join(chain(('option',), (word.lower() for word in findall(r'[a-z]+|[A-Z][a-z]*|[A-Z]+', name))))
        tag = getTagByID(tagID)
        assert tag.tagName.lower() == 'input', tag.tagName
        if name == 'taskName':
            exclude = r'''\/:\\?*'<">&\|'''  # ToDo: Generate title and placeholder too
            setAttr(tag, 'pattern', rf'[^{exclude}\s][^{exclude}]+[^{exclude}\s]')  # Also avoid whitespace at start and end
        args = self.TAG_ARGS[valueType]
        for (attr, attrValue) in args.items():
            setAttr(tag, attr, attrValue, onlyIfAbsent = True)  # Set <input> tag attributes according to value type
        inputType = args.get('type', 'text')
        setAttr(tag, 'type', inputType, onlyIfAbsent = True)  # Make sure <input type="text"> is always specified explicitly
        if inputType == 'text':
            setAttr(tag, 'maxlength', 4, onlyIfAbsent = True)
        if inputType == 'checkbox':
            tag.checked = value
        else:
            tag.value = value
        log(f"Options.configureTag({name}, {defaultValue!r}): {type(tag).__name__} {tag.getAttribute('type')} {tag.getAttribute('inputmode')} {tag.checked if inputType == 'checkbox' else tag.value!r}")

        @when('change', tag)  # type: ignore[untyped-decorator]
        async def update(e: Event) -> None:
            newValue: TagAttrValue = e.target.value
            assert isinstance(newValue, str), newValue
            if valueType is str:
                if name == 'taskName' and not newValue:
                    newValue = generate_slug(2)  # Provide random task name to save user from extra thinking
            elif valueType is bool:
                newValue = tag.checked
            elif newValue:  # int or float from non-empty string
                newValue = valueType(newValue)
            else:  # empty string
                newValue = defaultValue
            log(f"Options.update({name}, {newValue!r})")
            self[name] = newValue  # Save to database
            log(f"Options[{name}] = {self.get(name)!r}")
            tag.value = newValue  # Write processed value back to the input tag
            if name in ('maxPreviewWidth', 'maxPreviewHeight'):  # pylint: disable=use-set-for-membership
                self.updateStyle()
            await self.sync()  # Make sure database is really updated

    def updateStyle(self) -> None:
        self.styleSheet.replaceSync(f'''
.image-display {{
    max-width: {self.maxPreviewWidth}px;
    max-height: {self.maxPreviewHeight}px;
}}
        ''')

    def __getattribute__(self, name: str) -> Any:
        defaultValue = super().__getattribute__(name)
        #log(f"Options.__getattribute__({name}) = {defaultValue!r}: {type(defaultValue).__name__} ({isinstance(defaultValue, TagAttrValueType)})")
        if not isinstance(defaultValue, TagAttrValue):
            return defaultValue  # Not an option field
        ret = self.get(name, None)
        log(f"Options.get({name}) = {ret!r}")
        return defaultValue if ret is None else ret

    def __setattr__(self, name: str, value: TagAttrValue) -> None:
        try:
            defaultValue = super().__getattribute__(name)
            #log(f"Options.__getattribute__({name}) = {defaultValue!r}: {type(defaultValue).__name__} ({isinstance(defaultValue, TagAttrValueType)})")
            if isinstance(defaultValue, TagAttrValue):
                if isinstance(defaultValue, float):
                    assert isinstance(value, int | float), f"Incorrect type for option {name}: {type(value).__name__}, expected int or float"
                else:
                    assert isinstance(value, type(defaultValue)), f"Incorrect type for option {name}: {type(value).__name__}, expected {type(defaultValue).__name__}"
                log(f"Options[{name}] = {value!r}")
                self[name] = value
                self.sync()
                return
        except AttributeError:
            pass  # log(f"Options.__getattribute__({name}) = AttributeError")
        log(f"Options.__setattr__({name}) = {value!r}")
        super().__setattr__(name, value)

    @classmethod
    async def init(cls) -> None:
        global options  # noqa: PLW0603  # pylint: disable=global-statement
        if not options:
            options = await storage('steganography', storage_class = cls)

options: Options | None = None  # ToDo: Do we really need it to be global?

class Stage(Enum):
    SOURCE = 1
    PROCESSED = 2
    RESIZED = 3

class ImageBlock:
    ID_PREFIX: ClassVar[str] = 'image-'

    def __init__(self, stage: Stage) -> None:
        self.name = stage.name.lower()
        self.isUpload = stage is Stage.SOURCE
        self.render()

    def getTagID(self, detail: str) -> str:
        return f'{self.ID_PREFIX}{detail}-{self.name}'

    def getTag(self, detail: str) -> Element:
        return getTagByID(self.getTagID(detail))

    def hide(self, name: str) -> None:
        hide(self.getTag(name))

    def show(self, name: str) -> None:
        show(self.getTag(name))

    def getAttr(self, name: str, attr: str) -> str:
        return getAttr(self.getTag(name), attr)

    def setAttr(self, name: str, attr: str, value: str) -> None:
        setAttr(self.getTag(name), attr, value)

    def display(self, byteArray: bytes | Uint8Array | None, description: str = "") -> None:
        if src := self.getAttr('display', 'src'):
            revokeObjectURL(src)
        self.setAttr('description', TEXT, description)
        self.show('description')
        if byteArray is None:  # E.g. Esc was pressed in upload dialog
            self.setAttr('display', 'src', '')
            self.setAttr('display-link', 'href', '')
            self.setAttr('download-link', 'href', '')
            self.hide('display-block')
            self.hide('download-block')
        else:
            url = createObjectURLFromBytes(byteArray)
            self.setAttr('display', 'src', url)
            self.setAttr('display-link', 'href', url)
            self.setAttr('download-link', 'href', url)
            self.show('display-block')
            self.show('download-block')

    def render(self) -> None:  # ToDo: Should this be inlined?
        # Create DOM tag
        blockID = self.getTagID('block')
        block = getTagByID('template').clone(blockID)
        getTagByID('uploads' if self.isUpload else 'generated').append(block)

        # Assign named IDs to all children that have image-* classes
        for tag in block.find('*'):
            for clas in tag.classes:
                if clas.startswith(self.ID_PREFIX):
                    tag.id = f'{clas}-{self.name}'
                    break

        # Adjust children attributes
        self.setAttr('title', TEXT, self.name.capitalize() + " file")
        linkTarget = self.name + '.png'
        self.setAttr('download-link', 'download', linkTarget)
        self.setAttr('name', TEXT, linkTarget)
        if self.isUpload:
            self.hide('description')
        else:
            self.hide('upload-block')

        show(blockID)

        @when('change', self.getTag('upload'))  # type: ignore[untyped-decorator]
        async def uploadEventHandler(e: Event) -> None:
            removeChildren('generated')
            if fileName := e.target.value:
                fileName = getFileNameFromPath(fileName)
                self.setAttr('download-link', 'download', fileName)
                self.setAttr('name', TEXT, fileName)
                self.display(None, "Loading image...")
                await repaint()
                try:
                    file = e.target.files.item(0)  # ToDo: Generate test event?
                    byteArray = await fileToByteArray(file)
                    image = loadImage(byteArray.to_bytes())
                except Exception as ex:  # noqa : BLE001
                    self.display(None, f"Error loading image: {ex}")
                    return
                self.display(byteArray, f"{file.size} bytes {image.format} {getImageMode(image)} {image.width}x{image.height}")
                processed = ImageBlock(Stage.PROCESSED)
                processed.display(None, "Processing image...")
                await repaint()
                try:
                    image = processImage(image, **vars(options))
                except Exception as ex:  # noqa : BLE001
                    self.display(None, f"Error processing image: {ex}")
                    return
                processed.display(imageToBytes(image), f"{getImageMode(image)} {image.width}x{image.height}")
            else:
                self.display(None)

def startLoading() -> None:
    setAttr('versions', TEXT, f'''\
PyScript: {pyscriptVersion}
Pyodide: {pyodideVersion}
Python: {pythonVersion}
    ''')

def finishLoading() -> None:
    show('content')

async def main() -> None:
    startLoading()
    await Options.init()
    ImageBlock(Stage.SOURCE)
    finishLoading()

if __name__ == '__main__':
    create_task(main())  # noqa: RUF006

from __future__ import annotations

from asyncio import sleep
from re import split
from sys import version
from typing import cast, Any, TYPE_CHECKING

from coolname import generate_slug  # type: ignore[attr-defined]

from pyscript import when, window  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module
from pyscript.web import page  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module
from pyscript.ffi import to_js  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module

try:  # Try to identify PyScript version
    from pyscript import version as pyscriptVersion  # type: ignore[attr-defined]
except ImportError:
    try:
        from pyscript import __version__ as pyscriptVersion
    except ImportError:
        pyscriptVersion = next(tag.src for tag in page['script']).split('/')[-2] or "UNKNOWN"

from pyodide_js import version as pyodideVersion  # type: ignore[import-not-found]  # pylint: disable=import-error, wrong-import-order

from Steganography import getImageMode, imageToBytes, loadImage, processImage

if TYPE_CHECKING:
    Event = Any  # Workarounds for mypy as stuff cannot be imported from PyScript when not in a browser
    Element = Any
    Blob = Any
    Uint8Array = Any
    def createObjectURL(_file: Any) -> str: return ''  # pylint: disable=multiple-statements
    def revokeObjectURL(_url: str) -> None: pass  # pylint: disable=multiple-statements
else:
    Blob = window.Blob  # Simplifying addressing to JS classes and functions
    Uint8Array = window.Uint8Array
    createObjectURL = window.URL.createObjectURL
    revokeObjectURL = window.URL.revokeObjectURL
    window = None  # For cleaner code, make sure all used references are mentioned here

# Global error handling
# Task name (default: date_time)
# Input image (upload, regenerate)
# Lock image (upload, remove)
# Key image (upload, remove)
# Lock result (download)
# Key result (download)
# Test (download) - make it with really two images overlaid!
# Move loading log to the bottom
# Check Rigging HTML for ideas

# Options:
# Max preview size: width, height (independent)
# Resize input image to: width, height
# Key size: xN, width, height
# Working field size: xN, width, height
# Random key rotation (check)
# Resize key to lock?
# Better background (check)
# Regenerate

TEXT = 'text'

def log(*args: str) -> None:
    print(*args)

def getFileNameFromPath(path: str) -> str:  # It looks like 'pathlib' and `os` modules fail to parse `C:\fakepath\` paths generated by browser when uploading files
    return split(r'[/\\]', path)[-1]

def getRandomName() -> str:
    return cast(str, generate_slug(2))

async def repaint() -> None:
    await sleep(0.1)  # Yield control to the browser so that repaint could happen

def createObjectURLFromBytes(byteArray: bytes | Uint8Array) -> str:
    if isinstance(byteArray, bytes):
        byteArray = Uint8Array.new(byteArray)
    blob = Blob.new([byteArray,], to_js({'type': 'image/png'}))  # to_js() converts Python dict into JS object
    return createObjectURL(blob)

def getTagByID(tagID: str) -> Element:
    return page['#' + tagID][0]

def hide(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.add('hidden')

def show(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.remove('hidden')

def getAttr(element: str | Element, attr: str) -> str:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        return cast(str, element.innerText)
    return cast(str, element.getAttribute(attr))

def setAttr(element: str | Element, attr: str, value: str) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        element.innerText = value
    else:
        element.setAttribute(attr, value)

def removeChildren(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.innerHTML = ''

def getImageBlock(name: str) -> Element:
    return getTagByID('template').clone('image-block-' + name)

# ToDo: Can this function be inlined?
async def fileToByteArray(file: Any) -> Uint8Array:
    return Uint8Array.new(await file.arrayBuffer())

def showImage(name: str, byteArray: bytes | Uint8Array | None, description: str = "") -> None:
    if src := getAttr('image-display-' + name, 'src'):
        revokeObjectURL(src)
    setAttr('image-description-' + name, TEXT, description)
    show('image-description-' + name)
    if byteArray is None:  # E.g. Esc was pressed in upload dialog
        setAttr('image-display-' + name, 'src', '')
        setAttr('image-display-link-' + name, 'href', '')
        setAttr('image-download-link-' + name, 'href', '')
        hide('image-display-block-' + name)
        hide('image-download-block-' + name)
    else:
        url = createObjectURLFromBytes(byteArray)
        setAttr('image-display-' + name, 'src', url)
        setAttr('image-display-link-' + name, 'href', url)
        setAttr('image-download-link-' + name, 'href', url)
        show('image-display-block-' + name)
        show('image-download-block-' + name)

def renderImage(name: str, upload: bool = False) -> None:
    block = getImageBlock(name)
    for tag in block.find('*'):  # Assign named ids to all tags that have image-* classes
        for c in tag.classes:
            if c.startswith('image-'):
                tag.id = f'{c}-{name}'
                break
    getTagByID('uploads' if upload else 'generated').append(block)
    setAttr('image-title-' + name, TEXT, name.capitalize() + " file")
    setAttr('image-download-link-' + name, 'download', name + '.png')
    setAttr('image-name-' + name, TEXT, name + '.png')
    if upload:
        hide('image-description-' + name)
    else:
        hide('image-upload-block-' + name)
    show(block.id)

    @when('change', getTagByID('image-upload-' + name))  # type: ignore[untyped-decorator]
    async def uploadEventHandler(e: Event) -> None:
        removeChildren('generated')
        if fileName := e.target.value:
            fileName = getFileNameFromPath(fileName)
            setAttr('image-download-link-' + name, 'download', fileName)
            setAttr('image-name-' + name, TEXT, fileName)
            showImage(name, None, "Loading image...")
            await repaint()
            try:
                file = e.target.files.item(0)  # ToDo: Generate test event?
                byteArray = await fileToByteArray(file)
                image = loadImage(byteArray.to_bytes())
            except Exception as ex:  # noqa : BLE001
                showImage(name, None, f"Error loading image: {ex}")
                return
            showImage(name, byteArray, f"{file.size} bytes {image.format} {getImageMode(image)} {image.width}x{image.height}")
            renderImage('processed')
            showImage('processed', None, "Processing image...")
            await repaint()
            try:
                image = processImage(image)
            except Exception as ex:  # noqa : BLE001
                showImage(name, None, f"Error processing image: {ex}")
                return
            showImage('processed', imageToBytes(image), f"{getImageMode(image)} {image.width}x{image.height}")
        else:
            showImage(name, None)

def showVersions() -> None:
    setAttr('versions', TEXT, f'''\
PyScript: {pyscriptVersion}
Pyodide: {pyodideVersion}
Python: {version}''')

def finishLoading() -> None:
    show('content')

def main() -> None:
    showVersions()
    renderImage('source', upload = True)
    finishLoading()

if __name__ == '__main__':
    main()

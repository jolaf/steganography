from __future__ import annotations

from asyncio import create_task, sleep
from enum import Enum
from itertools import chain
from re import findall, split
from sys import version as pythonVersion
from typing import cast, Any, ClassVar, TYPE_CHECKING

from coolname import generate_slug  # type: ignore[attr-defined]

from pyscript import document, when, window, storage, Storage  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module
from pyscript.web import page  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module
from pyscript.ffi import to_js  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module

try:  # Try to identify PyScript version
    from pyscript import version as pyscriptVersion  # type: ignore[attr-defined]
except ImportError:
    try:
        from pyscript import __version__ as pyscriptVersion
    except ImportError:
        pyscriptVersion = next(tag.src for tag in page['script']).split('/')[-2] or "UNKNOWN"

try:
    from pyodide_js import version as pyodideVersion  # type: ignore[import-not-found]  # pylint: disable=import-error, wrong-import-order
except ImportError:
    pyodideVersion = "UNKNOWN"

from js import CSSStyleSheet  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module, wrong-import-order

from Steganography import getImageMode, imageToBytes, loadImage, processImage

if TYPE_CHECKING:
    from collections.abc import Mapping

    # Workarounds for mypy, as stuff cannot be imported from PyScript when not in a browser
    Event = Any
    Element = Any
    Blob = Any
    Uint8Array = Any
    Storage = Any
    def createObjectURL(_file: Any) -> str: return ''  # pylint: disable=multiple-statements
    def revokeObjectURL(_url: str) -> None: pass  # pylint: disable=multiple-statements
else:
    # Simplifying addressing to JS classes and functions
    Blob = window.Blob
    Uint8Array = window.Uint8Array
    createObjectURL = window.URL.createObjectURL
    revokeObjectURL = window.URL.revokeObjectURL
    window = None  # For cleaner code, make sure all used references are mentioned here

# ToDo: these:
# Global error handling
# Task name (default: date_time)
# Input image (upload, regenerate)
# Lock image (upload, remove)
# Key image (upload, remove)
# Lock result (download)
# Key result (download)
# Test (download) - make it with really two images overlaid!
# Move loading log to the bottom
# Check Rigging HTML for ideas

TEXT = 'text'

def log(*args: Any) -> None:
    print(*args)

def getFileNameFromPath(path: str) -> str:
    # It looks like 'pathlib' and `os` modules fail to parse `C:\fakepath\` paths generated by browser when uploading files
    return split(r'[/\\]', path)[-1]

async def repaint() -> None:
    await sleep(0.1)  # Yield control to the browser so that repaint could happen

def createObjectURLFromBytes(byteArray: bytes | Uint8Array) -> str:
    if isinstance(byteArray, bytes):
        byteArray = Uint8Array.new(byteArray)
    blob = Blob.new([byteArray,], to_js({'type': 'image/png'}))  # to_js() converts Python dict into JS object
    return createObjectURL(blob)

async def fileToByteArray(file: Any) -> Uint8Array:
    return Uint8Array.new(await file.arrayBuffer())

def getTagByID(tagID: str) -> Element:
    try:
        return page['#' + tagID][0]
    except IndexError:
        log("ERROR at getTagByID(): No tag ID found:", tagID)
        raise

def hide(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.add('hidden')

def show(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.remove('hidden')

def getAttr(element: str | Element, attr: str) -> str:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        return cast(str, element.innerText)
    return cast(str, element.getAttribute(attr))

def setAttr(element: str | Element, attr: str, value: str) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        element.innerText = value
    else:
        element.setAttribute(attr, value)

def removeChildren(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.innerHTML = ''

class Options(Storage):  # type: ignore[misc, no-any-unimported]
    OptionType = str | int | float | bool
    DEFAULT_VALUES: ClassVar[Mapping[type, OptionType]] = {int: 0, float: 1.0, bool: False}

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

        # These fields define correct names, types and default values for options:
        self.taskName = ''
        self.maxPreviewWidth = 500
        self.maxPreviewHeight = 200
        self.resizeFactor = 0
        self.resizeWidth = 0
        self.resizeHeight = 0
        self.cropWidth = 0
        self.cropHeight = 0
        self.keyFactor = 1.0
        self.keyWidth = 0
        self.keyHeight = 0
        self.keyRotate = False
        self.lockFactor = 1.0
        self.lockWidth = 0
        self.lockHeight = 0
        self.keyResize = False
        self.smoothBackground = False

        for (name, defaultValue) in vars(self).items():
            if isinstance(defaultValue, Options.OptionType):
                self.configureTag(name, defaultValue)

        # Create stylesheet to update with options
        self.styleSheet = CSSStyleSheet.new()
        document.adoptedStyleSheets.push(self.styleSheet)
        self.updateStyle()

    def configureTag(self, name: str, defaultValue: Options.OptionType) -> None:
        value = self.get(name, defaultValue)
        assert isinstance(value, Options.OptionType), f"Incorrect type for option {name}: {type(value).__name__}, expected {type(defaultValue).__name__}"
        tag = getTagByID('-'.join(chain(('option',), (word.lower() for word in findall(r'[a-z]+|[A-Z][a-z]*|[A-Z]+', name)))))
        if tag.type == 'checkbox':
            tag.checked = value
        else:
            tag.value = value
        log(f"Options.configureTag({name}, {defaultValue!r}): {type(tag).__name__} {tag.type} {tag.value!r}")

        @when('change', tag)  # type: ignore[untyped-decorator]
        async def update(e: Event) -> None:
            newValue: Options.OptionType = e.target.value
            assert isinstance(newValue, str), newValue
            if isinstance(defaultValue, str):
                if name == 'taskName' and not newValue:
                    newValue = generate_slug(2)
            elif newValue:  # int | float | bool
                newValue = type(defaultValue)(newValue)
            else:
                newValue = Options.DEFAULT_VALUES[type(defaultValue)]
            log(f"Options.update({name}, {newValue!r})")
            self[name] = newValue
            await self.sync()

    def updateStyle(self) -> None:
        self.styleSheet.replaceSync(f'''
.image-display {{
    max-width: {self.maxPreviewWidth}px;
    max-height: {self.maxPreviewHeight}px;
}}
        ''')

    @classmethod
    async def init(cls) -> None:
        global options  # noqa: PLW0603  # pylint: disable=global-statement
        if not options:
            options = await storage('steganography', storage_class = cls)

options: Options | None = None  # ToDo: Do we really need it to be global?

class Stage(Enum):
    SOURCE = 1
    PROCESSED = 2
    RESIZED = 3

class ImageBlock:
    ID_PREFIX: ClassVar[str] = 'image-'

    def __init__(self, stage: Stage) -> None:
        self.name = stage.name.lower()
        self.isUpload = stage is Stage.SOURCE
        self.render()

    def getTagID(self, detail: str) -> str:
        return f'{self.ID_PREFIX}{detail}-{self.name}'

    def getTag(self, detail: str) -> Element:
        return getTagByID(self.getTagID(detail))

    def hide(self, name: str) -> None:
        hide(self.getTag(name))

    def show(self, name: str) -> None:
        show(self.getTag(name))

    def getAttr(self, name: str, attr: str) -> str:
        return getAttr(self.getTag(name), attr)

    def setAttr(self, name: str, attr: str, value: str) -> None:
        setAttr(self.getTag(name), attr, value)

    def display(self, byteArray: bytes | Uint8Array | None, description: str = "") -> None:
        if src := self.getAttr('display', 'src'):
            revokeObjectURL(src)
        self.setAttr('description', TEXT, description)
        self.show('description')
        if byteArray is None:  # E.g. Esc was pressed in upload dialog
            self.setAttr('display', 'src', '')
            self.setAttr('display-link', 'href', '')
            self.setAttr('download-link', 'href', '')
            self.hide('display-block')
            self.hide('download-block')
        else:
            url = createObjectURLFromBytes(byteArray)
            self.setAttr('display', 'src', url)
            self.setAttr('display-link', 'href', url)
            self.setAttr('download-link', 'href', url)
            self.show('display-block')
            self.show('download-block')

    def render(self) -> None:  # ToDo: Should this be inlined?
        # Create DOM tag
        blockID = self.getTagID('block')
        block = getTagByID('template').clone(blockID)
        getTagByID('uploads' if self.isUpload else 'generated').append(block)

        # Assign named IDs to all children that have image-* classes
        for tag in block.find('*'):
            for clas in tag.classes:
                if clas.startswith(self.ID_PREFIX):
                    tag.id = f'{clas}-{self.name}'
                    break

        # Adjust children attributes
        self.setAttr('title', TEXT, self.name.capitalize() + " file")
        linkTarget = self.name + '.png'
        self.setAttr('download-link', 'download', linkTarget)
        self.setAttr('name', TEXT, linkTarget)
        if self.isUpload:
            self.hide('description')
        else:
            self.hide('upload-block')

        show(blockID)

        @when('change', self.getTag('upload'))  # type: ignore[untyped-decorator]
        async def uploadEventHandler(e: Event) -> None:
            removeChildren('generated')
            if fileName := e.target.value:
                fileName = getFileNameFromPath(fileName)
                self.setAttr('download-link', 'download', fileName)
                self.setAttr('name', TEXT, fileName)
                self.display(None, "Loading image...")
                await repaint()
                try:
                    file = e.target.files.item(0)  # ToDo: Generate test event?
                    byteArray = await fileToByteArray(file)
                    image = loadImage(byteArray.to_bytes())
                except Exception as ex:  # noqa : BLE001
                    self.display(None, f"Error loading image: {ex}")
                    return
                self.display(byteArray, f"{file.size} bytes {image.format} {getImageMode(image)} {image.width}x{image.height}")
                processed = ImageBlock(Stage.PROCESSED)
                processed.display(None, "Processing image...")
                await repaint()
                try:
                    image = processImage(image)
                except Exception as ex:  # noqa : BLE001
                    self.display(None, f"Error processing image: {ex}")
                    return
                processed.display(imageToBytes(image), f"{getImageMode(image)} {image.width}x{image.height}")
            else:
                self.display(None)

def startLoading() -> None:
    setAttr('versions', TEXT, f'''\
PyScript: {pyscriptVersion}
Pyodide: {pyodideVersion}
Python: {pythonVersion}
    ''')

def finishLoading() -> None:
    show('content')

async def main() -> None:
    startLoading()
    await Options.init()
    ImageBlock(Stage.SOURCE)
    finishLoading()

if __name__ == '__main__':
    create_task(main())  # noqa: RUF006

# ruff: noqa: E402  # pylint: disable=wrong-import-position
from __future__ import annotations

print("[python] Loading app")

from asyncio import create_task, get_running_loop, sleep, AbstractEventLoop
from collections.abc import Iterable, Mapping  # noqa: TC003
from enum import Enum
from itertools import chain
from re import findall, split
import sys
from sys import version as pythonVersion
from traceback import extract_tb
from types import TracebackType  # noqa: TC003
from typing import cast, Any, ClassVar, TYPE_CHECKING

from coolname import generate_slug  # type: ignore[attr-defined]

from beartype import beartype as typechecked

from pyscript import config as pyscriptConfig, when, storage, Storage  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module
from pyscript.web import page  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module
from pyscript.ffi import to_js  # type: ignore[import-not-found]  # pylint: disable=import-error, no-name-in-module

try:  # Try to identify PyScript version
    from pyscript import version as pyscriptVersion  # type: ignore[attr-defined]
except ImportError:
    try:
        from pyscript import __version__ as pyscriptVersion
    except ImportError:
        pyscriptVersion = next(tag.src for tag in page['script']).split('/')[-2] or "UNKNOWN"

from js import CSSStyleSheet, DataTransfer, Event as JSEvent  # type: ignore[attr-defined]  # pylint: disable=no-name-in-module, wrong-import-order

if TYPE_CHECKING:
    # Workarounds for mypy, as stuff cannot be imported from PyScript when not in a browser
    Element = Any
    def newBlob(_blobParts: Iterable[Any], _options: Any) -> Blob:
        pass
    def newFile(_fileBits: Iterable[Any], _fileName: str, _options: Any) -> File:
        pass
    def newUint8Array(_bytes: bytes) -> Uint8Array:
        pass
    def createObjectURL(_file: File) -> str:
        return ''
    def revokeObjectURL(_url: str) -> None:
        pass
    adoptedStyleSheets = Any
else:
    from pyscript import document  # type: ignore[attr-defined]
    from pyscript.web import Element  # type: ignore[import-not-found]
    from js import Blob, File, Uint8Array, URL  # type: ignore[attr-defined]

    # We'll redefine these classes to Any below, so we have to save all needed references
    newBlob = Blob.new
    newFile = File.new
    newUint8Array = Uint8Array.new

    # Simplifying addressing to JS functions
    createObjectURL = URL.createObjectURL
    revokeObjectURL = URL.revokeObjectURL
    del URL  # We won't need it anymore
    adoptedStyleSheets = document.adoptedStyleSheets
    del document  # We won't need it anymore

# JS types that don't work as runtime type annotations
Blob = Any
File = Any
Uint8Array = Any
Event = Any  # Neither PyScript nor JS versions work as runtime type annotation

try:
    from pyodide_js import version as pyodideVersion  # type: ignore[import-not-found]
except ImportError:
    pyodideVersion = "UNKNOWN"

from Steganography import getImageMode, imageToBytes, loadImage, processImage

TagAttrValue = str | int | float | bool

# Event names
CLICK = 'click'
CHANGE = 'change'

TEXT = 'text'  # Shortcut for innerText attribute

@typechecked
def log(*args: Any) -> None:
    message = ' '.join(str(arg) for arg in args)
    print("[python]", message)
    # noinspection PyProtectedMember
    getTagByID('log')._dom_element.append(message + '\n')  # We have to use _dom_element because PyScript version of append() is not working with strings as of v2025.11.2  # noqa: SLF001  # pylint: disable=protected-access
    test = message.lower()
    if any(word in test for word in ('error', 'exception')):
        page['#log'][0].classes.add('error')

@typechecked
def getFileNameFromPath(path: str) -> str:
    # It looks like 'pathlib' and `os` modules fail to parse `C:\fakepath\` paths generated by browser when uploading files
    return split(r'[/\\]', path)[-1]

@typechecked
async def repaint() -> None:
    await sleep(0.1)  # Yield control to the browser so that repaint could happen

@typechecked
def createObjectURLFromBytes(byteArray: bytes | Uint8Array) -> str:
    if isinstance(byteArray, bytes):
        byteArray = newUint8Array(byteArray)
    blob = newBlob([byteArray,], to_js({'type': 'image/png'}))  # to_js() converts Python dict into JS object
    return createObjectURL(blob)

@typechecked
async def blobToByteArray(blob: Blob) -> Uint8Array:
    return newUint8Array(await blob.arrayBuffer())

@typechecked
def getTagByID(tagID: str) -> Element:
    try:
        return page['#' + tagID][0]
    except IndexError:
        log("ERROR at getTagByID(): No tag ID found:", tagID)
        raise

@typechecked
def hide(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.add('hidden')

@typechecked
def show(element: str | Element) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.classes.remove('hidden')

@typechecked
def getAttr(element: str | Element, attr: str) -> str:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        return cast(str, element.textContent)
    return cast(str, element.getAttribute(attr))

@typechecked
def setAttr(element: str | Element, attr: str, value: TagAttrValue, onlyIfAbsent: bool = False) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    if attr == TEXT:
        if not onlyIfAbsent or not element.textContent:
            element.textContent = value
    elif not onlyIfAbsent or not element.getAttribute(attr):
        element.setAttribute(attr, value)

@typechecked
def dispatchEvent(element: str | Element, eventType: str) -> None:
    if isinstance(element, str):
        element = getTagByID(element)
    element.dispatchEvent(JSEvent.new(eventType))

@typechecked
class Stage(Enum):
    SOURCE = 1
    PROCESSED = 2
    RESIZED = 3

@typechecked
class Options(Storage):  # type: ignore[misc, no-any-unimported]
    TAG_ARGS: ClassVar[Mapping[type[TagAttrValue], Mapping[str, TagAttrValue]]] = {
        str: {
        },
        int: {
            'inputmode': 'numeric',
            'placeholder': 'integer',
            'pattern': r'[0-9]+',
            'default': 0,
        },
        float: {
            'inputmode': 'decimal',
            'placeholder': 'float resize factor',
            'pattern': r'\.[0-9]{1,2}|[0-9]+\.[0-9]{1,2}|[0-9]+\.?',
            'default': 1.0,
        },
        bool: {
            'type': 'checkbox',
            'default': False,
        },
    }

    def __init__(self, *args: Any, **kwargs: Any) -> None:  # Constructor is only called internally, so we don't know the args and don't care
        super().__init__(*args, **kwargs)
        #log("# Options: initializing default values")

        # These fields define names, types and DEFAULT values for options, actual values are stored in Storage
        self.taskName = ''
        self.maxPreviewWidth = 500
        self.maxPreviewHeight = 200
        self.resizeFactor = 1.0
        self.resizeWidth = 0
        self.resizeHeight = 0
        self.cropWidth = 0
        self.cropHeight = 0
        self.keyFactor = 1.0
        self.keyWidth = 0
        self.keyHeight = 0
        self.keyRotate = False
        self.lockFactor = 1.0
        self.lockWidth = 0
        self.lockHeight = 0
        self.keyResize = False
        self.dither = False
        self.smooth = False

        #log("# Options: configuring tags and connecting them to options")
        tags: list[Element] = []
        for (name, defaultValue) in vars(self).items():
            if isinstance(defaultValue, TagAttrValue):
                tags.append(self.configureTag(name, defaultValue))

        #log("# Options: configuring stylesheet to adjust with options")
        self.styleSheet = CSSStyleSheet.new()
        adoptedStyleSheets.push(self.styleSheet)
        self.updateStyle()

        #log("# Options: configuring Reset button")
        @when(CLICK, '#options-reset')  # type: ignore[untyped-decorator]
        @typechecked
        def resetEventHandler(_e: Event) -> None:
            for tag in tags:
                if tag.type == 'checkbox':
                    tag.checked = tag.default
                else:
                    tag.value = tag.default
                dispatchEvent(tag, CHANGE)

    @classmethod
    async def init(cls) -> None:
        global options  # noqa: PLW0603  # pylint: disable=global-statement
        if not options:
            options = await storage('steganography', storage_class = cls)
        for stage in Stage:
            ImageBlock(stage)

    def configureTag(self, name: str, defaultValue: TagAttrValue) -> Element:
        valueType = type(defaultValue)
        value = self.get(name, defaultValue)  # Read from database
        assert isinstance(value, valueType), f"Incorrect type for option {name}: {type(value).__name__}, expected {valueType.__name__}"
        tagID = '-'.join(chain(('option',), (word.lower() for word in findall(r'[a-z]+|[A-Z][a-z]*|[A-Z]+', name))))
        tag = getTagByID(tagID)
        assert tag.tagName.lower() == 'input', tag.tagName
        tag.default = defaultValue
        if name == 'taskName':
            exclude = r'''\/:\\?*'<">&\|'''  # ToDo: Generate title and placeholder too
            setAttr(tag, 'pattern', rf'[^{exclude}\s][^{exclude}]+[^{exclude}\s]')  # Also avoid whitespace at start and end
        args = self.TAG_ARGS[valueType]
        for (attr, attrValue) in args.items():
            setAttr(tag, attr, attrValue, onlyIfAbsent = True)  # Set <input> tag attributes according to value type
        inputType = args.get('type', 'text')
        setAttr(tag, 'type', inputType, onlyIfAbsent = True)  # Make sure <input type="text"> is always specified explicitly
        if inputType == 'text':
            setAttr(tag, 'maxlength', 4, onlyIfAbsent = True)
        if inputType == 'checkbox':
            tag.checked = value
        else:
            tag.value = value
        #log(f"Options.configureTag({name}, {defaultValue!r}): {type(tag).__name__} {tag.getAttribute('type')} {tag.getAttribute('inputmode')} {tag.checked if inputType == 'checkbox' else tag.value!r}")

        @when(CHANGE, tag)  # type: ignore[untyped-decorator]
        @typechecked
        async def changeEventHandler(_e: Event) -> None:
            newValue: TagAttrValue = tag.value
            if valueType is str:
                if name == 'taskName' and not newValue:
                    newValue = generate_slug(2)  # Provide random task name to save user from extra thinking
            elif valueType is bool:
                newValue = tag.checked
            elif newValue:  # int or float from non-empty string
                newValue = valueType(newValue)
            else:  # empty string
                newValue = defaultValue
            #log(f"Options.update({name}, {newValue!r})")
            self[name] = newValue  # Save to database
            #log(f"Options[{name}] = {self.get(name)!r}")
            tag.value = newValue  # Write processed value back to the input tag
            if name in ('maxPreviewWidth', 'maxPreviewHeight'):  # pylint: disable=use-set-for-membership
                self.updateStyle()
            await self.sync()  # Make sure database is really updated

        return tag

    def updateStyle(self) -> None:
        self.styleSheet.replaceSync(f'''
.image-display {{
    max-width: {self.maxPreviewWidth}px;
    max-height: {self.maxPreviewHeight}px;
}}
        ''')

    def saveFile(self, name: str, data: bytes | Uint8Array | None) -> None:
        self['file-' + name] = bytearray(data or b'')

    def loadFile(self, name: str) -> bytearray | None:
        return cast(bytearray | None, self.get('file-' + name))

    def __getattribute__(self, name: str) -> Any:
        defaultValue = super().__getattribute__(name)
        #log(f"Options.__getattribute__({name}) = {defaultValue!r}: {type(defaultValue).__name__} ({isinstance(defaultValue, TagAttrValueType)})")
        if not isinstance(defaultValue, TagAttrValue):
            return defaultValue  # Not an option field
        ret = self.get(name, None)
        #log(f"Options.get({name}) = {ret!r}")
        return defaultValue if ret is None else ret

    def __setattr__(self, name: str, value: Any) -> None:
        try:
            defaultValue = super().__getattribute__(name)
            #log(f"Options.__getattribute__({name}) = {defaultValue!r}: {type(defaultValue).__name__} ({isinstance(defaultValue, TagAttrValueType)})")
            if isinstance(defaultValue, TagAttrValue):
                if isinstance(defaultValue, float):
                    assert isinstance(value, int | float), f"Incorrect type for option {name}: {type(value).__name__}, expected int or float"
                else:
                    assert isinstance(value, type(defaultValue)), f"Incorrect type for option {name}: {type(value).__name__}, expected {type(defaultValue).__name__}"
                log(f"Options[{name}] = {value!r}")
                self[name] = value
                self.sync()
                return
        except AttributeError:
            pass  # log(f"Options.__getattribute__({name}) = AttributeError")
        #log(f"Options.__setattr__({name}) = {value!r}")
        super().__setattr__(name, value)

options: Options | None = None  # ToDo: Do we really need it to be global?

@typechecked
class ImageBlock:
    ID_PREFIX: ClassVar[str] = 'image-'

    def __init__(self, stage: Stage) -> None:
        self.name = stage.name.lower()
        self.isUpload = stage is Stage.SOURCE
        self.render()

    def getTagID(self, detail: str) -> str:
        return f'{self.ID_PREFIX}{detail}-{self.name}'

    def getTag(self, detail: str) -> Element:
        return getTagByID(self.getTagID(detail))

    def hide(self, name: str) -> None:
        hide(self.getTag(name))

    def show(self, name: str) -> None:
        show(self.getTag(name))

    def getAttr(self, name: str, attr: str) -> str:
        return getAttr(self.getTag(name), attr)

    def setAttr(self, name: str, attr: str, value: str) -> None:
        setAttr(self.getTag(name), attr, value)

    def saveFile(self, byteArray: bytes | Uint8Array | None) -> None:
        assert options
        options.saveFile(self.name, byteArray)

    def loadFile(self) -> bytearray | None:
        assert options
        return options.loadFile(self.name)

    def display(self, byteArray: bytes | Uint8Array | None, description: str = "") -> None:
        if src := self.getAttr('display', 'src'):
            revokeObjectURL(src)
        self.setAttr('description', TEXT, description)
        self.show('description')
        if byteArray is None:  # E.g. Esc was pressed in upload dialog
            self.setAttr('display', 'src', '')
            self.setAttr('display-link', 'href', '')
            self.setAttr('download-link', 'href', '')
            self.hide('display-block')
            self.hide('download-block')
        else:
            url = createObjectURLFromBytes(byteArray)
            self.setAttr('display', 'src', url)
            self.setAttr('display-link', 'href', url)
            self.setAttr('download-link', 'href', url)
            self.show('display-block')
            self.show('download-block')
            self.saveFile(byteArray)

    def render(self) -> None:  # ToDo: Should this be inlined?
        # Create DOM tag
        blockID = self.getTagID('block')
        block = getTagByID('template').clone(blockID)
        getTagByID('uploads' if self.isUpload else 'generated').append(block)

        # Assign named IDs to all children that have image-* classes
        for tag in block.find('*'):
            for clas in tag.classes:
                if clas.startswith(self.ID_PREFIX):
                    tag.id = f'{clas}-{self.name}'
                    break

        # Adjust children attributes
        self.setAttr('title', TEXT, self.name.capitalize() + " file")
        linkTarget = self.name + '.png'
        self.setAttr('download-link', 'download', linkTarget)
        self.setAttr('name', TEXT, linkTarget)
        if self.isUpload:
            self.hide('description')
        else:
            self.hide('upload-block')

        uploadTag = self.getTag('upload')

        @when(CHANGE, uploadTag)  # type: ignore[untyped-decorator]
        @typechecked
        async def uploadEventHandler(_e: Event) -> None:
            #removeChildren('generated')
            if fileName := uploadTag.value:
                fileName = getFileNameFromPath(fileName)
                self.setAttr('download-link', 'download', fileName)
                self.setAttr('name', TEXT, fileName)
                self.display(None, "Loading image...")
                await repaint()
                try:
                    file = uploadTag.files.item(0)  # ToDo: Generate test event?
                    byteArray = await blobToByteArray(file)
                    image = loadImage(byteArray.to_bytes())
                except Exception as ex:  # noqa : BLE001
                    self.display(None, f"Error loading image: {ex}")
                    return
                self.display(byteArray, f"{file.size} bytes {image.format} {getImageMode(image)} {image.width}x{image.height}")
                processed = ImageBlock(Stage.PROCESSED)
                processed.display(None, "Processing image...")
                await repaint()
                try:
                    image = processImage(image, **vars(options))
                except Exception as ex:  # noqa : BLE001
                    self.display(None, f"Error processing image: {ex}")
                    return
                processed.display(imageToBytes(image), f"{getImageMode(image)} {image.width}x{image.height}")
            else:
                self.display(None)

        # Load stored image
        if byteArray := self.loadFile():
            file = newFile([newUint8Array(byteArray),], 'test.name', to_js({'type': 'image/png'}))  # to_js() converts Python dict into JS object
            dataTransfer = DataTransfer.new()
            dataTransfer.items.add(file)
            uploadTag.files = dataTransfer.files
            #dispatchEvent(uploadTag, CHANGE)
            show(blockID)

@typechecked
def exceptionHandler(source: str, exceptionType: type[BaseException | None] | None = None, exception: BaseException | None = None, traceback: TracebackType | None = None) -> None:
    if exceptionType is None:
        exceptionType = type(exception)
    if traceback is None and exception:
        traceback = exception.__traceback__
    # Filter traceback to remove empty lines
    tracebackStr = '\n' + '\n'.join(line for line in '\n'.join(extract_tb(traceback).format()).splitlines() if line.strip()) if traceback else ''
    log(f"\nERROR Uncaught exception in {source}, type {exceptionType.__name__}: {exception}{tracebackStr}\n\nPlease make a screenshot and report it to @jolaf at Telegram or VK or to vmzakhar@gmail.com. Thank you!\n")

@typechecked
def mainExceptionHandler(exceptionType: type[BaseException] | None = None, exception: BaseException | None = None, traceback: TracebackType | None = None) -> None:
    exceptionHandler("main thread", exceptionType, exception, traceback)

@typechecked
def loopExceptionHandler(_loop: AbstractEventLoop, context: dict[str, Any]) -> None:
    exceptionHandler("async loop", exception = context.get('exception'))

@typechecked
async def main() -> None:
    log("Starting app")
    log("PyScript v" + pyscriptVersion)
    log("Pyodide v" + pyodideVersion)
    log("Python v" + pythonVersion)
    log("PyScript config:", pyscriptConfig)
    log("Configuring app")
    sys.excepthook = mainExceptionHandler
    get_running_loop().set_exception_handler(loopExceptionHandler)
    await Options.init()
    #ImageBlock(Stage.SOURCE)
    hide('log')
    show('content')
    log("Running app")
    #raise Exception("Booo in loop!")

if __name__ == '__main__':
    create_task(main())  # noqa: RUF006
    #raise Exception("Booo in main!")

print("[python] Loaded app")
